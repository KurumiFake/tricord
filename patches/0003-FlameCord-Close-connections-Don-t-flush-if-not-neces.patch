From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: foss-mc <69294560+foss-mc@users.noreply.github.com>
Date: Wed, 16 Dec 2020 18:06:17 +0800
Subject: [PATCH] (FlameCord) Close connections & Don't flush if not necessary


diff --git a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
index ed1fe41a..d091afa2 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
@@ -194,6 +194,13 @@ public class InitialHandler extends PacketHandler implements PendingConnection
                 }
 
                 ServerPing legacy = result.getResponse();
+
+                // FlameCord - Close and return if legacy == null
+                if (legacy == null) {
+                    ch.close();
+                    return;
+                }
+
                 String kickMessage;
 
                 if ( v1_5 )
@@ -259,6 +266,17 @@ public class InitialHandler extends PacketHandler implements PendingConnection
                     @Override
                     public void done(ProxyPingEvent pingResult, Throwable error)
                     {
+                        // FlameCord - Close if response is null
+                        if (pingResult.getResponse() == null) {
+                            ch.close();
+                            return;
+                        }
+
+                        // FlameCord - Return if connection is closed
+                        if (ch.isClosed()) {
+                            return;
+                        }
+
                         Gson gson = BungeeCord.getInstance().gson;
                         unsafe.sendPacket( new StatusResponse( gson.toJson( pingResult.getResponse() ) ) );
                         if ( bungee.getConnectionThrottle() != null )
@@ -288,11 +306,13 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     @Override
     public void handle(PingPacket ping) throws Exception
     {
-        if (!ACCEPT_INVALID_PACKETS) {
-            Preconditions.checkState(thisState == State.PING, "Not expecting PING");
-        }
+        // FlameCord - Never accept invalid packets
+        Preconditions.checkState( thisState == State.PING, "Not expecting PING" );
+
         unsafe.sendPacket( ping );
-        disconnect( "" );
+
+        // FlameCord - Close instead of disconnect
+        ch.close();
     }
 
     @Override
@@ -622,7 +642,8 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     {
         if ( canSendKickMessage() )
         {
-            ch.delayedClose( new Kick( ComponentSerializer.toString( reason ) ) );
+            // FlameCord - Changed delayedClose to close
+            ch.close( new Kick( ComponentSerializer.toString( reason ) ) );
         } else
         {
             ch.close();
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java b/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java
index 6dc5633f..5c05f2b9 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java
@@ -80,40 +80,27 @@ public class ChannelWrapper
 
             if ( packet != null && ch.isActive() )
             {
-                ch.writeAndFlush( packet ).addListeners( ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE, ChannelFutureListener.CLOSE );
+                // FlameCord - Remove the firing of exceptions on failure
+                ch.writeAndFlush( packet ).addListeners( ChannelFutureListener.CLOSE );
             } else
             {
-                ch.flush();
+                // FlameCord - Don't flush just close
                 ch.close();
             }
         }
     }
 
+    // FlameCord - Deprecate and "disable" delayedClose because it doesn't have a reason to exist
+    @Deprecated
     public void delayedClose(final Kick kick)
     {
-        if ( !closing )
-        {
-            closing = true;
-
-            // Minecraft client can take some time to switch protocols.
-            // Sending the wrong disconnect packet whilst a protocol switch is in progress will crash it.
-            // Delay 250ms to ensure that the protocol switch (if any) has definitely taken place.
-            ch.eventLoop().schedule( new Runnable()
-            {
-
-                @Override
-                public void run()
-                {
-                    close( kick );
-                }
-            }, 250, TimeUnit.MILLISECONDS );
-        }
+        close(kick);
     }
 
     public void addBefore(String baseName, String name, ChannelHandler handler)
     {
         Preconditions.checkState( ch.eventLoop().inEventLoop(), "cannot add handler outside of event loop" );
-        ch.pipeline().flush();
+        // FlameCord - Don't flush if not necessary
         ch.pipeline().addBefore( baseName, name, handler );
     }
 
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java b/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
index 2a21243b..a95193ba 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
@@ -5,6 +5,7 @@ import io.github.waterfallmc.waterfall.event.ConnectionInitEvent;
 import io.netty.buffer.PooledByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
+import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
@@ -98,6 +99,14 @@ public class PipelineUtils
 
             BungeeCord.getInstance().getPluginManager().callEvent(connectionInitEvent);
         }
+
+        // FlameCord - Close on exception caught
+        @Override
+        public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) throws Exception {
+            cause.printStackTrace();
+
+            ctx.close();
+        }
     };
     public static final Base BASE = new Base();
     private static final KickStringWriter legacyKicker = new KickStringWriter();
@@ -192,5 +201,13 @@ public class PipelineUtils
 
             ch.pipeline().addLast( BOSS_HANDLER, new HandlerBoss() );
         }
+
+        // FlameCord - Close on exception caught
+        @Override
+        public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) throws Exception {
+            cause.printStackTrace();
+
+            ctx.close();
+        }
     }
 }
diff --git a/query/src/main/java/net/md_5/bungee/query/QueryHandler.java b/query/src/main/java/net/md_5/bungee/query/QueryHandler.java
index 0c1ecfb8..b3bdfd05 100644
--- a/query/src/main/java/net/md_5/bungee/query/QueryHandler.java
+++ b/query/src/main/java/net/md_5/bungee/query/QueryHandler.java
@@ -71,6 +71,8 @@ public class QueryHandler extends SimpleChannelInboundHandler<DatagramPacket>
         if ( in.readUnsignedByte() != 0xFE || in.readUnsignedByte() != 0xFD )
         {
             bungee.getLogger().log( Level.WARNING, "Query - Incorrect magic!: {0}", msg.sender() );
+            // FlameCord - Close on incorrect magic
+            ctx.close();
             return;
         }
 
